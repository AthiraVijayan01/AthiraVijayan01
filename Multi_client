//CLIENT
#include<stdio.h>
#include<stdlib.h>
#include<sys/socket.h>
#include<sys/types.h>
#include<netinet/in.h>
#include<string.h>
#include<unistd.h>
#include<arpa/inet.h>
#include<sys/time.h>
#define BUFFER_SIZE 100
#define TIMEOUT_SECONDS 5 // Timeout in seconds
int main() {
int i, c_sock;
c_sock = socket(AF_INET, SOCK_STREAM, 0);
struct sockaddr_in client;
memset(&client, 0, sizeof(client));
client.sin_family = AF_INET;
client.sin_port = htons(9003);
client.sin_addr.s_addr = inet_addr("127.0.0.1");
if (connect(c_sock, (struct sockaddr*)&client, sizeof(client)) == -1) {
printf("Connection failed");
return 0;
}
char msg[50] = "client message:";
char buff[BUFFER_SIZE];
struct timeval timeout;
timeout.tv_sec = TIMEOUT_SECONDS;
timeout.tv_usec = 0;
setsockopt(c_sock, SOL_SOCKET, SO_RCVTIMEO, (const char*)&timeout, sizeof(timeout));
for (i = 0; i < 5; i++) {
int n = read(c_sock, buff, sizeof(buff));
if (n > 0) {
buff[n] = '\0';
printf("Message received from server: %s\n", buff);
printf("Enter acknowledgement message: ");
fgets(msg, sizeof(msg), stdin);
write(c_sock, msg, strlen(msg));
} else {
printf("Timeout occurred. No message received from server.\n");
// Resend the acknowledgment or take appropriate action
}
}
close(c_sock);
return 0;
}
MULTI CHAT
SERVER:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#define MAX_CLIENTS 10
#define BUFFER_SIZE 1024
typedef struct {
int id;
int socket;
struct sockaddr_in address;
pthread_t thread;
} Client;
Client clients[MAX_CLIENTS];
int client_count = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
void *handle_client(void *arg);
int main(int argc, char *argv[]) {
if (argc != 2) {
printf("Usage: %s <port>\n", argv[0]);
return 1;
}
int server_socket, client_socket;
struct sockaddr_in server_addr, client_addr;
socklen_t client_addr_len = sizeof(client_addr);
server_socket = socket(AF_INET, SOCK_STREAM, 0);
if (server_socket == -1) {
perror("Socket creation failed");
return 1;
}
server_addr.sin_family = AF_INET;
server_addr.sin_addr.s_addr = INADDR_ANY;
server_addr.sin_port = htons(atoi(argv[1]));
if (bind(server_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
perror("Socket bind failed");
close(server_socket);
return 1;
}
if (listen(server_socket, 5) == -1) {
perror("Socket listen failed");
close(server_socket);
return 1;
}
printf("Server started. Waiting for connections...\n");
while (1) {
client_socket = accept(server_socket, (struct sockaddr *)&client_addr, &client_addr_len);
if (client_socket == -1) {
perror("Accept failed");
continue;
}
pthread_mutex_lock(&mutex);
if (client_count < MAX_CLIENTS) {
Client *client = &clients[client_count++];
client->id = client_count;
client->socket = client_socket;
client->address = client_addr;
if (pthread_create(&client->thread, NULL, handle_client, (void *)client) != 0) {
perror("Thread creation failed");
close(client_socket);
client_count--;
}
} else {
printf("Maximum clients reached. Connection rejected.\n");
close(client_socket);
}
pthread_mutex_unlock(&mutex);
}
close(server_socket);
return 0;
}
void *handle_client(void *arg) {
Client *client = (Client *)arg;
char buffer[BUFFER_SIZE];
printf("New client connected: %s:%d\n", inet_ntoa(client->address.sin_addr), ntohs(client-
>address.sin_port));
while (1)
{
int bytes_received = recv(client->socket, buffer, BUFFER_SIZE, 0);
if (bytes_received <= 0)
{
printf("Client %d disconnected.\n", client->id);
break;
}
buffer[bytes_received] = '\0'; // Ensure the received buffer is null-terminated
char message_buffer[BUFFER_SIZE + 10]; // Add space for appending client ID
snprintf(message_buffer, sizeof(message_buffer), "%s %d",buffer,client->id); // Append sender
client ID to message
char *token = strtok(message_buffer, " ");
if (token != NULL)
{
int dest_client_id = atoi(token);
char *message = strtok(NULL, "\n");
if (message != NULL)
{
pthread_mutex_lock(&mutex);
for (int i = 0; i < client_count; i++)
{
if (clients[i].id == dest_client_id)
{
// Include sender client ID in the message
snprintf(buffer, BUFFER_SIZE, "%d: %s",client->id,message);
send(clients[i].socket, buffer, strlen(buffer), 0);
break;
}
}
pthread_mutex_unlock(&mutex);
}
}
}
close(client->socket);
pthread_exit(NULL);
}
CLIENT:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#define BUFFER_SIZE 1024
void *receive_messages(void *arg);
int main(int argc, char *argv[]) {
if (argc != 3) {
printf("Usage: %s <server_ip> <port>\n", argv[0]);
return 1;
}
int client_socket;
struct sockaddr_in server_addr;
char buffer[BUFFER_SIZE];
client_socket = socket(AF_INET, SOCK_STREAM, 0);
if (client_socket == -1) {
perror("Socket creation failed");
return 1;
}
server_addr.sin_family = AF_INET;
server_addr.sin_addr.s_addr = inet_addr(argv[1]);
server_addr.sin_port = htons(atoi(argv[2]));
if (connect(client_socket, (struct sockaddr *)&server_addr, sizeof(server_addr)) == -1) {
perror("Connection failed");
close(client_socket);
return 1;
}
printf("Connected to server. Start chatting...\n");
pthread_t recv_thread;
if (pthread_create(&recv_thread, NULL, receive_messages, (void *)&client_socket) != 0) {
perror("Thread creation failed");
close(client_socket);
return 1;
}
while (1) {
fgets(buffer, BUFFER_SIZE, stdin);
if (send(client_socket, buffer, strlen(buffer), 0) == -1) {
perror("Send failed");
break;
}
}
close(client_socket);
return 0;
}
void *receive_messages(void *arg) {
int client_socket = *((int *)arg);
char buffer[BUFFER_SIZE];
while (1) {
int bytes_received = recv(client_socket, buffer, BUFFER_SIZE, 0);
if (bytes_received <= 0) {
printf("Disconnected from server.\n");
break;
}
buffer[bytes_received] = '\0';

int sender_client_id;
sscanf(buffer, "%d: %[^\n]", &sender_client_id, buffer); // Extract sender client ID

printf("from %d: %s\n", sender_client_id, buffer); // Print sender client ID along with message
}
pthread_exit(NULL);
}
SELECTIVE REPEAT
CLIENT
#include<time.h>
#include<stdio.h>
#include<stdlib.h>
#include<sys/socket.h>
#include<sys/types.h>
#include<netinet/in.h>
#include<sys/time.h>
#include<sys/wait.h>
#include<string.h>
#include<unistd.h>
#include<arpa/inet.h>
int isfaulty(){
int d=rand()%4;
//printf("%d\n",d);
return (d>2);
}
int main() {
srand(time(0));
int c_sock;
c_sock = socket(AF_INET, SOCK_STREAM, 0);
struct sockaddr_in client;
memset(&client, 0, sizeof(client));
client.sin_family = AF_INET;
client.sin_port = htons(9009);
client.sin_addr.s_addr = inet_addr("127.0.0.1");
if(connect(c_sock, (struct sockaddr*)&client, sizeof(client)) == -1) {
printf("Connection failed");
return 0;
}
printf("\n\tClient -with individual acknowledgement scheme\n\n");
char msg1[50]="akwnowledgementof-";
char msg3[50]="negative akwn-";
char msg2[50];
char buff[100];
int count=-1,flag=1;
while(count<8){
bzero(buff,sizeof(buff));
bzero(msg2,sizeof(msg2));
if(count==7&&flag==1){
//sleep(3);
printf("here\n"); //simulate loss
//i--;
flag=0;
read(c_sock,buff,sizeof(buff));
//printf("aa %s \n",buff);
continue;
}
int n = read(c_sock, buff, sizeof(buff));
char i=buff[strlen(buff)-1];
printf("Message received from server : %s \n",buff);
int isfault=isfaulty();
printf("correption status : %d \n",isfault);
printf("Response/akwn sent for message \n");
if(isfault)
strcpy(msg2,msg3);
else{
strcpy(msg2,msg1);
count++;}
msg2[strlen(msg2)]=i;
write(c_sock,msg2, sizeof(msg2));
}
close(c_sock);
return 0;
}
SERVER
#include <stdio.h>
#include <stdlib.h>
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/time.h>
#include <netinet/in.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <fcntl.h>
void rsendd(int ch, int c_sock)
{
char buff2[60];
bzero(buff2, sizeof(buff2));
strcpy(buff2, "reserver message :");
buff2[strlen(buff2)] = (ch) + '0';
buff2[strlen(buff2)] = '\0';
printf("Resending Message to client :%s \n", buff2);
write(c_sock, buff2, sizeof(buff2));
usleep(1000);
}
int main()
{
int s_sock, c_sock;
s_sock = socket(AF_INET, SOCK_STREAM, 0);
struct sockaddr_in server, other;
memset(&server, 0, sizeof(server));
memset(&other, 0, sizeof(other));
server.sin_family = AF_INET;
server.sin_port = htons(9009);
server.sin_addr.s_addr = INADDR_ANY;
socklen_t add;
if (bind(s_sock, (struct sockaddr *)&server, sizeof(server)) == -1)
{
printf("Binding failed\n");
return 0;
}
printf("\tServer Up\n Selective repeat scheme\n\n");
listen(s_sock, 10);
add = sizeof(other);
c_sock = accept(s_sock, (struct sockaddr *)&other, &add);
time_t t1, t2;
char msg[50] = "server message :";
char buff[50];
int flag = 0;
fd_set set1, set2, set3;
struct timeval timeout1, timeout2, timeout3;
int rv1, rv2, rv3;
int tot = 0;
int ok[20];
memset(ok, 0, sizeof(ok));
while (tot < 9)
{
int toti = tot;
for (int j = (0 + toti); j < (3 + toti); j++)
{
// printf("%d %d %d \n",tot,toti,j);
bzero(buff, sizeof(buff));
char buff2[60];
bzero(buff2, sizeof(buff2));
strcpy(buff2, "server message :");
buff2[strlen(buff2)] = (j) + '0';
buff2[strlen(buff2)] = '\0';
printf("Message sent to client :%s \n", buff2);
write(c_sock, buff2, sizeof(buff2));
usleep(1000);
}
for (int k = 0 + toti; k < (toti + 3); k++)
{
qq:
FD_ZERO(&set1);
FD_SET(c_sock, &set1);
timeout1.tv_sec = 2;
timeout1.tv_usec = 0;
rv1 = select(c_sock + 1, &set1, NULL, NULL, &timeout1);
if (rv1 == -1)
perror("select error ");
else if (rv1 == 0)
{
printf("Timeout for message :%d \n", k);
rsendd(k, c_sock);
goto qq;
} // a timeout occured
else
{
read(c_sock, buff, sizeof(buff));
printf("Message from Client: %s\n", buff);
if (buff[0] == 'n')
{
printf(" corrupt message awk (msg %d) \n", buff[strlen(buff) - 1] - '0');
rsendd((buff[strlen(buff) - 1] - '0'), c_sock);
goto qq;
}
else
tot++;
// printf("%d %d %d \n",tot,toti,k);
}
}
}
close(c_sock);
close(s_sock);
return 0;
}
